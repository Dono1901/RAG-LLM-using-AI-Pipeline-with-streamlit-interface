name: Self-Heal

on:
  workflow_run:
    workflows: ["CI"]
    types: [completed]
  schedule:
    - cron: "0 */6 * * *"  # Every 6 hours
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: read

jobs:
  analyze-failures:
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'workflow_run' &&
      github.event.workflow_run.conclusion == 'failure'
    steps:
      - uses: actions/checkout@v4

      - name: Analyze CI failure
        id: analyze
        uses: actions/github-script@v7
        with:
          script: |
            const runId = context.payload.workflow_run.id;
            const branch = context.payload.workflow_run.head_branch;

            // Get failed jobs
            const { data: jobs } = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: runId,
            });

            const failedJobs = jobs.jobs.filter(j => j.conclusion === 'failure');
            const failureDetails = failedJobs.map(j => `- **${j.name}**: ${j.conclusion}`).join('\n');

            // Classify failure type
            let failureType = 'unknown';
            let autoFixable = false;

            for (const job of failedJobs) {
              const name = job.name.toLowerCase();
              if (name.includes('lint') || name.includes('format')) {
                failureType = 'lint-format';
                autoFixable = true;
              } else if (name.includes('test')) {
                failureType = 'test';
              } else if (name.includes('security')) {
                failureType = 'security';
              } else if (name.includes('docker')) {
                failureType = 'docker-build';
              }
            }

            core.setOutput('failure_type', failureType);
            core.setOutput('auto_fixable', autoFixable.toString());
            core.setOutput('branch', branch);
            core.setOutput('run_id', runId.toString());
            core.setOutput('failure_details', failureDetails);

      - name: Create issue for unfixable failures
        if: steps.analyze.outputs.auto_fixable == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const failureType = '${{ steps.analyze.outputs.failure_type }}';
            const branch = '${{ steps.analyze.outputs.branch }}';
            const runId = '${{ steps.analyze.outputs.run_id }}';
            const details = `${{ steps.analyze.outputs.failure_details }}`;

            const labels = ['needs-attention'];
            if (failureType === 'security') labels.push('security');
            if (failureType === 'test') labels.push('bug');

            // Check for existing open issue about same failure type
            const { data: existingIssues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'needs-attention',
              per_page: 20,
            });

            const recentSame = existingIssues.find(i =>
              i.title.includes(`[CI Failure]`) &&
              i.title.includes(failureType) &&
              new Date(i.created_at) > new Date(Date.now() - 24 * 60 * 60 * 1000)
            );

            if (!recentSame) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `[CI Failure] ${failureType} failure on ${branch}`,
                body: `## CI Failure Analysis\n\n**Type**: ${failureType}\n**Branch**: ${branch}\n**Run**: ${context.payload.workflow_run.html_url}\n\n### Failed Jobs\n${details}\n\n*Auto-generated by self-heal workflow*`,
                labels: labels,
              });
            }

  retry-flaky:
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'workflow_run' &&
      github.event.workflow_run.conclusion == 'failure'
    steps:
      - name: Check if flaky (failed < 3 of last 5 runs)
        id: flaky
        uses: actions/github-script@v7
        with:
          script: |
            const { data: runs } = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'ci.yml',
              per_page: 5,
            });

            const failures = runs.workflow_runs.filter(r => r.conclusion === 'failure').length;
            const isFlaky = failures > 0 && failures < 3;
            core.setOutput('is_flaky', isFlaky.toString());
            core.setOutput('failure_count', failures.toString());

      - name: Retry CI if flaky
        if: steps.flaky.outputs.is_flaky == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            // Re-run the failed workflow (max 1 retry per failure)
            try {
              await github.rest.actions.reRunWorkflowFailedJobs({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: context.payload.workflow_run.id,
              });
              console.log('Retried flaky CI run');
            } catch (e) {
              console.log('Could not retry:', e.message);
            }

  periodic-check:
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    steps:
      - uses: actions/checkout@v4

      - name: Track failure patterns
        uses: actions/github-script@v7
        with:
          script: |
            // Get recent workflow runs
            const { data: runs } = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'ci.yml',
              per_page: 20,
            });

            const recent = runs.workflow_runs.slice(0, 20);
            const failures = recent.filter(r => r.conclusion === 'failure');
            const failureRate = (failures.length / recent.length * 100).toFixed(1);

            console.log(`CI failure rate (last 20 runs): ${failureRate}%`);
            console.log(`Failures: ${failures.length}/${recent.length}`);

            // Alert if failure rate > 30%
            if (failures.length > 6) {
              const { data: existingIssues } = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                labels: 'needs-attention',
                per_page: 10,
              });

              const hasAlert = existingIssues.some(i =>
                i.title.includes('[CI Health]') &&
                new Date(i.created_at) > new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
              );

              if (!hasAlert) {
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: `[CI Health] High failure rate: ${failureRate}%`,
                  body: `## CI Health Alert\n\n**Failure rate**: ${failureRate}% (${failures.length}/${recent.length} recent runs)\n\nThis may indicate a systemic issue. Recent failures:\n${failures.slice(0, 5).map(f => `- [Run #${f.run_number}](${f.html_url}) on ${f.head_branch}`).join('\n')}\n\n*Auto-generated by self-heal periodic check*`,
                  labels: ['needs-attention', 'component: ci-cd'],
                });
              }
            }
